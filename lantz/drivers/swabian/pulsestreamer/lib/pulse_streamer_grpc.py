#import grpc-package
from grpc import insecure_channel
import sys
#from time import *

try:
    #import the python wrapper generated by the protocol buffer compiler (source: pulse_streamer.proto)
    from lantz.drivers.swabian.pulsestreamer.lib.pulse_streamer_pb2 import VoidMessage, PulseMessage, SequenceMessage, ClockMessage, DrpClkSetMessage, GetSerialMessage, TriggerMessage, SetNetworkMessage, EnableStaticIPMessage, PulseStreamerStub
except Exception as e:
    print('Exception: '+ str(e))
    print (
"""
Failed to import simple wrapper generated by the protobuf compiler (source: pulse_streamer.proto)
- Ensure pulse_streamer_pb2.py is in the search path.
Required packages: grpcio, protobuf
""")
    sys.exit(1)

import numpy as np
from enum import Enum

class Serial(Enum):
    ID = 0
    MAC = 1

class Clock_source(Enum):
    INTERNAL = 0
    EXT_125MHZ = 1
    EXT_10MHZ = 2

class Start(Enum):
    IMMEDIATE = 0
    SOFTWARE = 1
    HARDWARE_RISING = 2
    HARDWARE_FALLING = 3
    HARDWARE_RISING_AND_FALLING = 4

class Mode(Enum):
    NORMAL = 0
    SINGLE = 1

class PulseStreamer():
    """
    Simple python wrapper for a PulseStreamer 8/2
    that describes pulses in the form (time, ['ch0', 'ch3'], 0.8, -0.4),
    where time is an integer in ns (clock ticks),
    ['ch0','ch3'] is a list naming the channels that should be high
    the last two numbers specify the analog outputs in volt.
    """

    TIMEOUT = 200
    
    def __init__(self, ip_hostname='pulsestreamer'):
        print("Connect to Pulse Streamer via google-RPC.")
        print("IP / Hostname:", ip_hostname)

        self.INFINITE = -1
        self.CONSTANT_ZERO = (0,0,0,0)

        try:
            channel = insecure_channel(ip_hostname + ':50051')
            self.stub = PulseStreamerStub(channel)
            try:
                g = GetSerialMessage()
                g.serial = getattr(GetSerialMessage, Serial.MAC.name)
                self.stub.getSerial(g, timeout=PulseStreamer.TIMEOUT)
            except:
                try:
                    void = VoidMessage()
                    self.stub.isRunning(void, timeout=PulseStreamer.TIMEOUT)
                    print ("Pulse Streamer class not compatible with current firmware. Please update your firmware.")
                    sys.exit(1)
                except:
                    print("No Pulse Streamer found at IP/Host-address: "+ip_hostname)
                    sys.exit(1)
        except:
            print("No Pulse Streamer found at IP/Host-address: "+ip_hostname)
            sys.exit(1)
        
    def reset(self):
        void = VoidMessage()
        return self.stub.reset(void, timeout=PulseStreamer.TIMEOUT)
        
    def constant(self, pulse):
        if (pulse == 'CONSTANT_ZERO' or pulse == 'constant_zero'):
            t, chans, a0, a1 = self.CONSTANT_ZERO
            pulse = PulseMessage(ticks=t, digi=chans, ao0=a0, ao1=a1)
        else:
            if isinstance(pulse[1], list):
                pulse = self.convert_pulse(pulse)
            else:
                t, chans, a0, a1 = pulse
                pulse = PulseMessage(ticks=t, digi=chans, ao0=a0, ao1=a1)
        self.stub.constant(pulse, timeout=PulseStreamer.TIMEOUT)

    def forceFinal(self):
        void = VoidMessage()
        self.stub.forceFinal(void, timeout=PulseStreamer.TIMEOUT)
        
    def stream(self, seq, n_runs='INFINITE', final='CONSTANT_ZERO'):
        check = list(filter(lambda x: abs(x[2])>=2**15 or abs(x[3])>=2**15 , seq))
        if check!=[]:
            print (""" Failed because of wrong range of pulse_data 
            The range of analog channel values is -32768 to 32768 (int_16t)
            """)
            sys.exit()

        s = SequenceMessage()
        if type(seq[0][1])== list:
            for i in range(len(seq)):
                s.pulse.extend([self.convert_pulse(seq[i])])
        else:
            for i in range(len(seq)):
                t, chans, a0, a1 = seq[i]
                s.pulse.extend([PulseMessage(ticks=t, digi=chans, ao0=a0, ao1=a1)])

        if (n_runs == 'INFINITE' or n_runs == 'infinite'):
            n_runs = self.INFINITE

        s.n_runs = n_runs

        if (final == 'CONSTANT_ZERO' or final == 'constant_zero'):
            t, chans, a0, a1 = self.CONSTANT_ZERO
            conv_final = PulseMessage(ticks=t, digi=chans, ao0=a0, ao1=a1)
        else:
            if isinstance(final[1], list):
                conv_final = self.convert_pulse(final)
            else:
                t, chans, a0, a1 = final
                conv_final = PulseMessage(ticks=t, digi=chans, ao0=a0, ao1=a1)

        s.final.ticks = conv_final.ticks
        s.final.digi = conv_final.digi
        s.final.ao0 = conv_final.ao0
        s.final.ao1 = conv_final.ao1
  
        self.stub.stream(s, timeout=PulseStreamer.TIMEOUT)
            
    def isStreaming(self):
        void = VoidMessage()
        return self.stub.isStreaming(void, timeout=PulseStreamer.TIMEOUT).value

    def hasSequence(self):
        void = VoidMessage()
        return self.stub.hasSequence(void, timeout=PulseStreamer.TIMEOUT).value

    def hasFinished(self):
        void = VoidMessage()
        return self.stub.hasFinished(void, timeout=PulseStreamer.TIMEOUT).value

    def startNow(self):
        void = VoidMessage()
        return self.stub.startNow(void, timeout=PulseStreamer.TIMEOUT).value

    def selectClock(self, clock_source):
        if not isinstance(clock_source, Clock_source):
            raise TypeError("clock_source must be an instance of Clock_source Enum")
        else:
            c = ClockMessage()
            c.clock_source = getattr(ClockMessage, clock_source.name)
            return self.stub.selectClock(c, timeout=PulseStreamer.TIMEOUT).value

    def getFirmwareVersion(self):
        void = VoidMessage()
        return self.stub.getFirmwareVersion(void, timeout=PulseStreamer.TIMEOUT).string_value

    def flash_lic(self):
        void = VoidMessage()
        return self.stub.flash_lic(void, timeout=PulseStreamer.TIMEOUT).string_value

    def getSerial(self, serial=Serial.MAC):
        if not isinstance(serial, Serial):
            raise TypeError("serial must be an instance of Serial Enum")
        else:
            g = GetSerialMessage()
            g.serial = getattr(GetSerialMessage, serial.name)
            return self.stub.getSerial(g, timeout=PulseStreamer.TIMEOUT).string_value

    def setClkParam(self, value=0):
        assert value in range(58)
        v= DrpClkSetMessage()
        v.value = value
        return self.stub.setClkParam(v, timeout=PulseStreamer.TIMEOUT).value

    def setTrigger(self, start, mode=Mode.NORMAL):
        if not isinstance(start, Start):
            raise TypeError("start must be an instance of Start Enum")
        else:
            if not isinstance(mode, Mode):
                raise TypeError("mode must be an instance of Mode Enum")
            else:
                t = TriggerMessage()
                t.start = getattr(TriggerMessage, start.name)
                t.mode = getattr(TriggerMessage, mode.name)
                return self.stub.setTrigger(t, timeout=PulseStreamer.TIMEOUT).value

    def rearm(self):
        void = VoidMessage()
        return self.stub.rearm(void, timeout=PulseStreamer.TIMEOUT).value
    
    def setNetworkConf(self, ip, netmask, gateway):
        n=SetNetworkMessage()
        n.ip=ip
        n.netmask=netmask
        n.gateway=gateway
        return self.stub.setNetworkConf(n, timeout=PulseStreamer.TIMEOUT).string_value

    def getNetworkConf(self):
        void = VoidMessage()
        return self.stub.getNetworkConf(void, timeout=PulseStreamer.TIMEOUT).string_value

    def testNetworkConf(self):
        void = VoidMessage()
        return self.stub.testNetworkConf(void, timeout=PulseStreamer.TIMEOUT).value

    def enableStaticIP(self, permanent=False):
        assert permanent in [True, False]
        e=EnableStaticIPMessage()
        e.permanent=permanent
        return self.stub.enableStaticIP(e, timeout=PulseStreamer.TIMEOUT).string_value

    def getUnderflow(self):
        void = VoidMessage()
        return self.stub.getUnderflow(void, timeout=PulseStreamer.TIMEOUT).value

    def getDebugRegister(self):
        void = VoidMessage()
        return self.stub.getDebugRegister(void, timeout=PulseStreamer.PulseStreamer.TIMEOUT).value
    
    def convert_pulse(self, pulse):
        t, chans, a0, a1 = pulse

        p = PulseMessage(ticks=t, digi=self.chans_to_mask(chans), ao0=int(round(0x7fff*a0)), ao1=int(round(0x7fff*a1)))
        if p.digi>=2**8:
            print (""" Failed because of wrong range of pulse_data 
            The range of digital channel mask is 255 (byte)
            """)
            sys.exit()
        return p

    def chans_to_mask(self, chans):
        mask = 0
        for chan in chans:
            mask |= 1<<chan
        return mask
        
        
def get_random_seq(min_len=0, max_len=1024, n_pulses=1000):
    """
    Generate a sequence of random pulses on the digital
    channels 1-7 and the two analog channels.

    Digital channel 0 is used as a trigger.    
    """
    t = np.random.uniform(min_len, max_len, n_pulses).astype(int)
    seq = [ (8, [0], 0, 0) ] # 8 ns trigger pulse on channel 0
    for i, ti in enumerate(t):
            state = i%2
            seq += [ (ti, state*[i for i in range(1, 8)], 1.0*state, -1.0*state) ]
    return seq

"""---------Test-Code-------------------------------"""

if __name__ == '__main__':
    pulser = PulseStreamer(ip_hostname='pulsestreamer')

    print("Serial number:", pulser.getSerial())
    print("Firmware Version:", pulser.getFirmwareVersion())

    pulser.stream(get_random_seq())
    print(get_random_seq())

    